# Unity GPU Tilemap

**2D 游戏开发**，甚至 **3D + 2D 的游戏开发**，或者**游戏的小地图**，我们都有可能会用到 **Tilemap**。

**Tilemap** 就不赘述了，如果欠缺这方面的知识，可以去百度一下，非常简单的。

我们有一张**非常大的 2D 场景**。地图上有**非常多元素。**
如果我们使用 Tilemap 来做，需要生成一份很大的数据，运行时构成这个地图，CPU 也需要花费一点点代价。
如，CPU 需要创建网格，理论上有多少个元素，你就要创建多少个。同时，提交渲染的时候，为了降低 DrawCall 的开销，也许你还要合批。
这是一些比较痛苦的事情。

**如果，我们把视野再拉的很远，视野中出现的 Tile 单位过多，也许这也是在给 CPU 带来的压力。**

其实，往往很多时候，我们做一些 2D 游戏，场景的地表，我们只是想要一个**单纯的渲染。**
也许不需要碰撞盒，不需要交互，我们完全没有必要在 CPU 构造这么一份实体（Mesh、碰撞、逻辑......）

我们可以利用 **GPU 的采样技术**，来进行一个**单纯就是渲染 2D Tilemap 的场景。**

## [github](https://github.com/wantdabo/goblin.gputilemap)

# 此处，我们先看下效果图。
![155]( ./Image/Sample_1.png)

你应该能看见，Unity Stats 的三角面只有 2 个，顶点数只有 4 个。
PS：Unity 它自身就有 2 个三角面与 4 个顶点的开销。所以我们需要简单做下减法就能得到我们业务开销的数值。

此时，你应该关注一下材质中的参数。

- **_TilemapBlockRate**
  - Tile 的尺寸缩放比。举个例子，图中的比例。32x32 的一份 Map 地图，这里要计算每一个 Tile 在这 32x32 中的占比。所以，1 / 32 就是我们的数值。如果，我们的 Map 的大小是 2x2 的话，那我们应该是 1 / 2 的缩放比。
- **_SampleBlockRate**
  - 采样图的缩放比，也就是我们的图集中每一个采样 Tile 的缩放比。他的计算方式同上，因为我们的采样图是一个 2x2 的集合。所以 1 / 2 就是他的缩放比。
- **_TilemapTex**
  - 这是一个非常**关键的贴图**，它就是我们 **Tilemap 构成的规则本身**，他将告诉我们的 **GPU** 该**怎么去绘制这个地图。**
- **_MainTex**
  - 采样图，可以看到，我们的采样图中，拥有 **4 个 Tile 的数据**。提供给 **GPU 采样**罢了。

简单介绍完参数，我们接下来重点来讲讲 TilemapTex。

## *_TilemapTex
**_TilemapTex  就是我们的 Map**，这是一张**贴图**。
你也看到了。
就是那张，颜色奇奇怪怪，像彩虹的贴图。
我也放到工程里了。
也在使用了。
屏幕也渲染了。
好了，不说废话了。

这是一张 **32x32 像素**的贴图。非常小的一张图，不过它的作用非常的大。
**1024 = 32x32**，这张帖图可以帮我们构建 **1024 个 Tile** 到屏幕上去渲染。
如何做到的呢？

32x32 的贴图，也包含这 **1024 个像素点**对吧！
此时，我们继续去到**微观的世界**，一个**像素**就是一个 **Color**。
Color 是如何构成的呢？
**Color.R、Color.G、Color.B、Color.A**
拥有**四个通道**，每一个通道的值是  **byte (0 - 255)**

如果，**R 通道、G 通道**，用来表示这个像素，在 **_TilemapTex  贴图上的 UV** 呢？
同时，**B 通道、A 通道**，用来表示这个像素，对应在 ** _MainTex 贴图上的 UV** 呢？

此处说的很抽象，所以，我们直接看 Shader 代码。
``` shader lab
fixed4 frag (v2f i) : SV_Target
{
	// 读取数据图中 rgba
	// r 表示 自身 x
	// g 表示 自身 y
	// b 表示映射采样图 x
	// a 表示映射采样图 y
	// 注意，此处的 x，y 均为贴图的左下角
	fixed4 dataTileMapCol = tex2D(_TilemapTex, i.uv);

	// 计算，mesh uv 自身左下角的溢出 uv 值。
	fixed2 overflowUv = i.uv - dataTileMapCol.rg;

	// 溢出的部分，用来 / block 的缩放比例。得到缩放比例，用来映射采样图的 uv 比例。
	fixed2 scaleUv = overflowUv / _TilemapBlockRate;

	// 映射采样图比例
	fixed2 mapping2SampleUv = scaleUv * _SampleBlockRate;

	// 开始最终采样，这是一个加法，需要加上 ba 采样的 uv 偏移，以及映射的比例即可。
	fixed4 col = tex2D(_MainTex, dataTileMapCol.ba + mapping2SampleUv);

	return col;
}
```

> 注意，因为每个通道只有 0 - 255，因此 uv 的精度有限。超过一定范围的数量的地图尺寸，将会导致采样错误。导致画面诡异。当然，这也是有办法解决的。我们需要新增多一张 _TilemapTex 来增加我们的数据精度。0 - 255 就可以变成 0 - 65535。如果还不够，可以考虑增加到 4 张 _TilemapTex 来提供 uv。如果是 4 个字节的话，精度不应该还会有问题。
